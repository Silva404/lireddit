"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EntityComparator = void 0;
const enums_1 = require("../enums");
const Utils_1 = require("./Utils");
class EntityComparator {
    constructor(metadata, platform) {
        this.metadata = metadata;
        this.platform = platform;
    }
    /**
     * Computes difference between two entities. First calls `prepareEntity` on both, then uses the `diff` method.
     */
    diffEntities(a, b) {
        return Utils_1.Utils.diff(this.prepareEntity(a), this.prepareEntity(b));
    }
    /**
     * Removes ORM specific code from entities and prepares it for serializing. Used before change set computation.
     * References will be mapped to primary keys, collections to arrays of primary keys.
     */
    prepareEntity(entity) {
        if (entity.__prepared) {
            return entity;
        }
        const meta = this.metadata.get(entity.constructor.name);
        const ret = {};
        if (meta.discriminatorValue) {
            ret[meta.root.discriminatorColumn] = meta.discriminatorValue;
        }
        // copy all comparable props, ignore collections and references, process custom types
        meta.comparableProps.forEach(prop => {
            if (this.shouldIgnoreProperty(entity, prop)) {
                return;
            }
            if (prop.reference === enums_1.ReferenceType.EMBEDDED) {
                return meta.props.filter(p => { var _a; return ((_a = p.embedded) === null || _a === void 0 ? void 0 : _a[0]) === prop.name; }).forEach(childProp => {
                    ret[childProp.name] = Utils_1.Utils.copy(entity[prop.name][childProp.embedded[1]]);
                });
            }
            if (Utils_1.Utils.isEntity(entity[prop.name], true)) {
                ret[prop.name] = Utils_1.Utils.getPrimaryKeyValues(entity[prop.name], this.metadata.find(prop.type).primaryKeys, true);
                if (prop.customType) {
                    return ret[prop.name] = Utils_1.Utils.copy(prop.customType.convertToDatabaseValue(ret[prop.name], this.platform));
                }
                return;
            }
            if (prop.customType) {
                return ret[prop.name] = Utils_1.Utils.copy(prop.customType.convertToDatabaseValue(entity[prop.name], this.platform));
            }
            if (prop.type.toLowerCase() === 'date') {
                return ret[prop.name] = Utils_1.Utils.copy(this.platform.processDateProperty(entity[prop.name]));
            }
            if (Array.isArray(entity[prop.name]) || Utils_1.Utils.isObject(entity[prop.name])) {
                return ret[prop.name] = Utils_1.Utils.copy(entity[prop.name]);
            }
            ret[prop.name] = Utils_1.Utils.copy(entity[prop.name]);
        });
        Object.defineProperty(ret, '__prepared', { value: true });
        return ret;
    }
    /**
     * should be used only for `meta.comparableProps` that are defined based on the static `isComparable` helper
     */
    shouldIgnoreProperty(entity, prop) {
        if (!(prop.name in entity)) {
            return true;
        }
        const value = entity[prop.name];
        const noPkRef = Utils_1.Utils.isEntity(value, true) && !value.__helper.hasPrimaryKey();
        const noPkProp = prop.primary && !Utils_1.Utils.isDefined(value, true);
        // bidirectional 1:1 and m:1 fields are defined as setters, we need to check for `undefined` explicitly
        const isSetter = [enums_1.ReferenceType.ONE_TO_ONE, enums_1.ReferenceType.MANY_TO_ONE].includes(prop.reference) && (prop.inversedBy || prop.mappedBy);
        const emptyRef = isSetter && value === undefined;
        return noPkProp || noPkRef || emptyRef || prop.version;
    }
    /**
     * perf: used to generate list of comparable properties during discovery, so we speed up the runtime comparison
     */
    static isComparable(prop, root) {
        const virtual = prop.persist === false;
        const inverse = prop.reference === enums_1.ReferenceType.ONE_TO_ONE && !prop.owner;
        const discriminator = prop.name === root.discriminatorColumn;
        const collection = prop.reference === enums_1.ReferenceType.ONE_TO_MANY || prop.reference === enums_1.ReferenceType.MANY_TO_MANY;
        return !virtual && !collection && !inverse && !discriminator && !prop.version;
    }
}
exports.EntityComparator = EntityComparator;
